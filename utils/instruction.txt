1. Настройка сборочного сервера.

1.1 Создаем VM-1, например, в YndexCloud (2 vCPU, 8GB RAM, 93 Gb HDD, public IPv4)
1.2 Добавляем открытый ssh-ключ в момент конфигурирования VM-1, сгенерированный на локальной машине, с которой будем подключаться. Если на локальной машине ключей несколько, указываем нужный с помощью переключателя -i
1.3 Заходим на VM-1 
ssh vm_01_adm_cse@158.160.48.90
1.4 Устанавливаем обновления
sudo apt-get update
sudo apt-get upgrade
1.5 Java environment (можно поставить конкретную версию)
sudo apt-get install default-jre
1.6 Устанавливаем Jenkins 
https://www.jenkins.io/doc/book/installing/linux/#debianubuntu
1.6.1 Проверяем
sudo service jenkins status
1.6.2 Заходим через Web interface 
http://158.160.48.90:8080/
и устанавливаем необходимые плагины. Меняем настройки по умолчанию при необходимости.
1.7 Устанавливаем Docker
https://docs.docker.com/engine/install/ubuntu/#install-using-the-convenience-script
1.7.1 Добавляем нужных пользователей в группу docker
sudo usermod -aG docker vm_01_adm_cse
id vm_01_adm_cse #смотрим, что теперь этот пользователь входит в группу docker
sudo usermod -aG docker jenkins
(см. документацию https://www.digitalocean.com/community/questions/how-to-fix-docker-got-permission-denied-while-trying-to-connect-to-the-docker-daemon-socket)
1.7.2 Перелогиниваемся, проверяем, что Docker service работает
docker image list
1.7.3 Рестартуем Jenkins
http://158.160.48.90:8080/restart

1.8 Клонируем репозитарий с утилитами для системы автоматической сборки
git clone https://github.com/adv-dev-22/cpp_cmake_ops.git
1.8.1 Переходим в поддиректорию 
cd cpp_cmake_ops/docker
и создаем докер-образ для сборки стандартным компилятором под x86_64
docker build -t ubuntu_x86_84:v12 -f Dockerfile_x86_64 .
docker image ls
Должно получиться что-то вроде
REPOSITORY      TAG       IMAGE ID       CREATED         SIZE
ubuntu_x86_84   v12       d3191ef2328d   4 minutes ago   470MB


2.1 Настройка Jenkins сборки вручную
Создаем новый проект.
2.1.1 Удалять устаревшие сборки - да.
2.1.1.1 Сколько последних сборок хранить - 5.
2.1.2 Управление исходным кодом - Git
2.1.2.1 Repository URL - https://github.com/libsdl-org/libtiff.git
2.1.3 Delete workspace before build starts - да.
2.2 Добавляем шаг сборки. Выполнить команду shell. Вставляем текст
echo "------------------ Build Started ------------------"

SRC_PATH=$WORKSPACE
mkdir build-default
docker run --rm --name test_x86_64_12 -v $SRC_PATH:/app/src ubuntu_x86_84:v12 "cd /app/src/build-default && cmake .. && cmake --build ." 

echo "------------------ Build Finished ------------------"

2.3 Добавляем шаг сборки. Выполнить команду shell. Вставляем текст
echo "------------------ Test Started ------------------"

SRC_PATH=$WORKSPACE
docker run --rm --name test_x86_64_12 -v $SRC_PATH:/app/src ubuntu_x86_84:v12 "cd /app/src/build-default && cmake --build . --target test > results_test_$BUILD_NUMBER.txt" 

echo "------------------ Test Finished ------------------"

2.4 Добавляем шаг сборки. Выполнить команду shell. Вставляем текст
echo "------------------ Deploy Started ------------------"

SRC_PATH=$WORKSPACE
less $SRC_PATH/build-default/results_test_$BUILD_NUMBER.txt

echo "------------------ Deploy Finished ------------------"

На этом этапе можно запустить сборку вручную и убедиться, что билды работают.


3. Настройка передачи данных на сервер/хранилище артефактов.
3.1 Создаем VM-2, например, в YndexCloud (2 vCPU, 5GB RAM, 50 Gb HDD, public IPv4)
3.2 Добавляем открытый ssh-ключ в момент конфигурирования VM-2, сгенерированный на локальной машине, с которой будем подключаться. Если на локальной машине ключей несколько, указываем нужный с помощью переключателя -i.
3.3 Заходим на первую машину VM-1 (сборочную) и генерерируем связку ключей, которые будут нужны для подключения к deploy-серверу VM-2
ssh-keygen
3.4 На VM-2 добавляем открытый ключ с VM-1 в authorized_keys
echo sh-rsa A...Gp6c= vm_01_adm_cse@ubuntu-server-01 >> authorized_keys
3.5 Проверяем, что копирование на удаленный сервер работает
scp ./README.md  vm_02_adm_cse@158.160.100.247:/home/vm_02_adm_cse/
Здесь 158.160.100.247 IPv4 адрес VM-2

3.6 Устанавливаем plugin Publish over SSH. Рестартуем Jenkins
3.7 Идем в Dashboard -> Настроить Jenkins -> System. Нам нужен раздел Publish over SSH.
3.7.1 Добавляем в поле Key приватный ключ из пункта 3.3 лежащий по адресу /home/vm_01_adm_cse/.ssh/id_rsa
3.7.2 В разделе SSH Servers указываем следующие параметры
Name: yc-ubuntu-deploy-02 # Просто название, можно указать любое удобное
Hostname:158.160.100.247 - IP VM-2 на которую будем деплоить артефакты
Username: vm_02_adm_cse
Remote Directory: /home/vm_02_adm_cse/deploy  #Можно зайти на VM-2 сервер и создать нужную
3.7.3 Тестируем подключение, получаем success
3.8 В настройках проекта сборки в разделе Послесборочные операции выбираем
Send build artifacts over SSH 
3.8.1 Выбираем единственный сервер yc-ubuntu-deploy-02
3.8.2 Source files: build-default/results_test_$BUILD_NUMBER.txt #будем отправлять результаты тестов
3.8.3 Remove prefix: build-default/
3.8.4 Remote directory: build-default/tests_out
Сохраняемся, запускаем сборку и в конце видим примерно такой вывод:
SSH: Connecting from host [ubuntu-server-01]
SSH: Connecting with configuration [yc-ubuntu-deploy-02] ...
SSH: Disconnecting configuration [yc-ubuntu-deploy-02] ...
SSH: Transferred 1 file(s)
Finished: SUCCESS
Можно зайти на Deploy-сервер и проверить, что файл скопирован.
3.9 Добавляем ssh ключи для пользователя jenkins (для того, чтобы можно было скопировать по scp
файл(ы) с билд-машины на  deploy-server)
sudo su jenkins -
3.9.1 Выполняем шаги 3.3 - 3.5 для пользователя jenkins
3.9.2 Добавляем в deploy-секцию 2.4 команду
scp $SRC_PATH/build-default/libtiff/libtiff.so vm_02_adm_cse@158.160.106.106:/home/vm_02_adm_cse/deploy/build-default/libs_out/libtiff_$BUILD_NUMBER.so



!!!!!!!!
При последующей настройке автоматической сборки на jenkins можно сохранить проект
 .... 
и развернуть проект из консоли.





